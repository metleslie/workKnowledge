## 1.什么是JVM
JVM就是我们常说的JAVA虚拟机，他是Java能够跨平台的基石。
程序运行之前，需要先通过编译器将Java源代码文件编译成字节码文件；
程序运行的时候，JVM会逐行对字节码进行解释，翻译成机器码指令，并交给对应的操作系统去执行。不同的版本有不同的JVM，针对操作系统。

实现一次编译处处运行的特点。

其他特性
- JVM可以自动管理内存，就是我们常说的GC回收。通过垃圾回收器将不再使用的对象回收。
- JVM包含一个即时编译器JIT，可以把热点代码翻译成机器码放到CodeCache里面，下次执行的时候不再一行一行的解释，而是直接执行缓存后的机器码，执行效率大幅度提高。
- 任何可以通过Java编译的语言，都可以在JVM运行，例如Kotlin，Groovy等

学习JVM的好处：
- 优化程序性能，避免内存问题
- 了解JVM的内存模型和垃圾回收机制，更便于我们合理分配内存，减少GC停顿
- JVM的类加载机制可以帮我们排查类加载冲突或异常
- JVM提供了很多调试工具，可以帮我们分析内存和线程的使用情况，从而解决内存溢出等问题

JVM的出现原因
跨平台可以用直译器，但是速度过慢，所以推出了JVM虚拟机，可以把字节码文件转换成机器码，转换的时候通过JIT做优化，这样的程序跑起来就快多了。

## 2.JVM的组织架构
类加载器：负责从文件系统，网络或其他来源加载Class文件，将Class文件中的二进制数据读入到内存中。
运行时数据区：JVM在执行JAVA程序时，需要在内存中分配空间来处理各种数据，这些内存区域按照Java虚拟机规范可以划分为方法区，堆，栈，虚拟机栈，程序计数器和本地方法栈。
执行引擎：JVM的心脏，负责执行字节码，包含一个**虚拟处理器**，即时编译器JIT以及垃圾回收器。

### JVM如何运行Java文件

### 编译时
当我们写了一个Java文件的时候，要让JVM运行，首先要通过JAVAC去编译，JAVAC是JDK里面的一个程序，专门用来把.java源文件编译成.class文件也就是字节码文件，在IDEA编译器里，可以使用show bytecode查看字节码文件。

我们在out文件夹里面能直接看到java格式的文件是因为IDEA用了FernFlower反编译工具将字节码文件反编译为我们看的懂的JAVA文件。

字节码包含了JVM的指令，类的元数据信息比如类名，方法和属性等

### 运行时
当我们有了字节码文件，我们就可以启动JVM来运行字节码文件，也就是到了RUN阶段，之前是build阶段。

JVM通过类加载器加载字节码文件，转换成二进制数据存储到运行时数据区，再通过执行引擎转换为机器码，最终交给操作系统执行。

接着执行引擎开始执行代码，我们的字节码指令通常包含多个指令组成，每条指令由一个操作码和若干操作数组成。
#### PC寄存器
JVM靠这些指令来执行程序，在==执行时我们的每个线程一个PC寄存器，它存储当前要执行的字节码指令，执行完一条后执行自动指向下一条，遇到条件分支，PC改成跳转后的地址，遇到native方法PC 置为 `undefined`（因为执行权交给了本地方法）==

#### 线程和栈帧
==每个线程有自己的虚拟机栈，每次调用方法就会往里面放入该方法的栈帧，栈帧里有局部变量，操作数栈，方法返回地址，方法执行完毕栈帧弹出==

#### 线程切换的时候，PC寄存器和虚拟机栈
切换线程时，PC寄存器存放的是当前线程的字节码指令地址（程序计数）
线程私有每个线程有自己的PC
当线程被调度时，JVM会保存当前线程PC寄存器的值（线程的执行位置）
当线程恢复执行时，会恢复之前保存的PC寄存器值，继续从上次停下的指令处执行。

虚拟机栈也是线程私有，保存该线程所有正在执行方法的栈帧
当线程切换时
- 虚拟机栈和栈帧会全部保存，因为他们在自己的线程空间中
- JVM会暂停该线程，但是栈帧信息保持不变。
恢复线程时，JVM会恢复虚拟机栈的状态，栈帧顶帧，局部变量和操作数帧都和上次一样，程序继续执行。

==可以理解为比赛暂停，全部信息不动，等到比赛恢复，全部按照当前暂停前的样子继续执行==
我们可以使用JAVAP查看字节码的指令序列
```
0 getstatic #2 <java/lang/System.out> 3 ldc #3 <Hello World> 5 invokevirtual #4 <java/io/PrintStream.println> 8 return
```
这是一个输出helloword的指令序列
字节码指令通常包含多条指令组成，每条指令由一个操作码和若干操作数组成。
JVM就是靠这些字节码指令来完成程序执行的，常见的执行方式有两种一种是解释执行，对字节码逐条执行，一种是JIT，也就是即时编译，他会在执行热点代码时把热点代码优化并缓存起来，下次再执行时直接使用缓存的机器码执行，不需要再次解释执行，大大增加了执行效率。

## 3.深入理解JVM运行时数据区

Java文件通过编译器形成.class文件，通过类加载器加载完毕交给执行引擎。在执行的过程中，JVM会划出一块空间来存储程序执行期间用到的数据，这块空间一般被称为运行时数据区

由五部分构成
虚拟机栈，方法区，PC寄存器，堆，本地方法栈

### 程序计数器（PC寄存器）
程序计数器占的内存很小，可以看作是当前线程所执行的字节码指令的行号指示器。字节码解释器会在工作的时候改变这个程序计数器的值来选取下一条需要执行的字节码指令，像循环，分支跳转等都需要这个程序计数器来完成。
在JVM中，线程是可以切换的，因此在任一具体时刻，一个CPU的内核只会执行一个线程中的指令，因此，为了切换线程后能恢复到正确的执行位置，每个线程有个独立的计数器，不能互相干扰，否则会影响正常的执行顺序。

也就是说程序计数器是线程私有的。

如果执行的是本地方法，计数器里面是underdefined，非本地，则保存的是当前需要执行的指令地址。

### Java虚拟机栈
Java虚拟机栈里面是一个个栈帧，每个栈帧对应一个方法，也是线程私有的，当我们执行一个方法的时候，会创建该方法对应的栈帧，并将栈帧压入栈中。

栈帧包含五个部分：
局部变量表
操作数帧
指向运行时常量池的引用
方法返回地址
动态链接
![[Pasted image 20250813095159.png]]
特点：
- 线程私有
- 栈溢出，如果栈的深度超过了JVM所允许的深度，则会报StackOverflowError
默认大小
默认 1024 KB 的 JVM 栈可以执行 10885 次 `testStackOverflowError` 方法，而 256 KB 的 JVM 栈只能执行 1990 次 `testStackOverflowError` 方法，四五倍的样子。

### 本地方法栈
本地方法栈与虚拟机栈类似，虚拟机执行JAVA方法服务，本地方法栈执行Native方法

### 堆
堆是所有线程共享的空间，在JVM启动的时候创建，用来存储对象（数组也是一种对象）
以前Java所有的对象都会在堆中分配，但随着JIT的发展和逃逸技术的形成，不是所有对象都分配到堆上了，JDK7默认开启逃逸分析，一个方法里面如果对象引用没有被返回或者未被外面使用，我们直接把这个对象存到虚拟机栈里面。

这个栈就是前面说的线程私有的虚拟机栈，随着方法调用的结束而消失，也就不需要被垃圾回收了。

逃逸分析（Escape Analysis）是一种编译器优化技术，用于判断对象的作用域和生命周期。如果编译器确定一个对象不会逃逸出方法或线程的范围，它可以选择在栈上分配这个对象，而不是在堆上。这样做可以减少垃圾回收的压力，并提高性能。
==逃逸分析不会出逃不一定是在栈上分配也有可能是标量替换，对象直接拆分成若干局部变量==。

堆除了是对象的聚集地，也是垃圾回收的主要处理区域，也叫做GC堆。

堆容易出现的错误是堆溢出OUTOFMEmoryerror
分为两种情况：
- JVM花太多时间回收并且只能回收很少的空间。
- 创建新对象，堆里面的内存不够创建了，也就是JVM内存太小了
- `OutOfMemoryError: GC Overhead Limit Exceeded`：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生该错误。
- `java.lang.OutOfMemoryError: Java heap space`：假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发该错误。和本机的物理内存无关，和我们配置的虚拟机内存大小有关！

### 元空间和方法区
元空间是一个逻辑区域，不同的版本有不同的实现，1.7是方法区被称为永久代，JDK8的时候，永久代被删除，被元空间替代。

JDK7之前，所有的常量池都在方法区里，之后把字符串常量池放到了堆里。到了JDK8运行时常量池放到了元空间里，字符串常量池还在堆里面

废弃永久代的原因：为了兼容JIT，有JIT功能的JVM没有永久代，为了兼容把永久代取消了，直接占用内存的一部分，并且把这块内存叫做元空间。
元空间大小不再受制于JVM启动时设置的大小，直接利用本地内存，也就是操作系统的内存，有效的解决了OOM的问题。

当元空间的数据增长时，JVM 会请求操作系统分配更多的内存。如果内存空间足够，操作系统就会满足 JVM 的请求。但是也会出现内存溢出的情况。

### 运行时常量池
常量池包含类里面的信息，包括类名，方法名一类的东西，但只是记录信息，并没有直接引用，运行时常量池就是直接引用了堆内的信息，类似于一个存地址，一个直接存坐标。

#### 常量池指什么
并不是简单的常量信息
不光有我们定义的3.14,"hello"
还有符号引用-也就是类名方法名字段名类型一类的
还有final常量
包含类运行前的所有信息

#### 运行时常量池指什么
运行时常量池简单来说就是常量池信息放到了运行时常量池这个新空间也就是元空间里面，但是我们的符号引用，例如一个A方法，常量池里面存储的是包名/类名/某个方法，但是运行时会解析这个地址直接找到堆里面这个方法的地方直接就引用地址了例如上述方法变成了一个1adfa2这种地址，好处是执行效率高，不用在运行时解析了，还有就是符合延迟加载和动态绑定，延迟加载是有些类只使用一次，所以编译时不用解析，动态绑定需要运行的时候才能找到具体使用的方法，你运行时就直接引用可能会错误。

### 字符串常量池
为什么放到堆里面
JDK6之前放到永久代里面，Stringintern方法会把字符串放进永久代的常量池
永久代空间小，放太多导致OOM

JDK就把字符串常量池放到堆里面，这样就不会导致OOM溢出，堆有更高效的GC回收，`String.intern()` 允许运行时动态往字符串常量池里加对象


### 总结
- PC 寄存器（PC Register），也叫程序计数器（Program Counter Register），是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器。
- JVM 栈（Java Virtual Machine Stack），与 PC 寄存器一样，JVM 栈也是线程私有的。每一个 JVM 线程都有自己的 JVM 栈（也叫方法栈），这个栈与线程同时创建，它的生命周期与线程相同。
- 本地方法栈（Native Method Stack），JVM 可能会使用到传统的栈来支持 [Native 方法](https://javabetter.cn/oo/native-method.html)的执行，这个栈就是本地方法栈。
- 堆（Heap），在 JVM 中，堆是可供各条线程共享的运行时内存区域，也是供所有类实例和数据对象分配内存的区域。
- 方法区（Method area），JDK 8 开始，使用元空间取代了永久代。**方法区是 JVM 中的一个逻辑区域**，用于存储类的结构信息，包括类的定义、方法的定义、字段的定义以及字节码指令。不同的是，元空间不再是 JVM 内存的一部分，而是通过本地内存（Native Memory）来实现的。
- [运行时常量池](https://javabetter.cn/jvm/neicun-jiegou.html)，运行时常量池是每一个类或接口的常量在运行时的表现形式，它包括了编译器可知的数值字面量，以及运行期解析后才能获得的方法或字段的引用。简而言之，当一个方法或者变量被引用时，JVM 通过运行时常量区来查找方法或者变量在内存里的实际地址。

## 4.对象创建的过程
当我们使用new关键字创建一个对象的时候，==JVM会在常量池中定位到类的符号引用（包括类名方法名属性等信息），查看符号引用是否解析，如果没有解析则加载类和解析，得到类的直接引用，然后JVM会为对象分配内存在堆里，并完成初始化，例如数值成员变量为0，对象是null等。==

接下来设置对象头，里面包含==对象是哪个类的实例，对象的哈希码，对象的GC分代年龄等信息==。
==最后JVM会执行构造方法《init》完成赋值操作==，将成员变量赋值为预期值例如int age = 18。

### 对象销毁过程
当对象不在被任何类引用时，就会变成垃圾。GC会通过==可达性算法==判断对象是否存活，如果对象不可达，则回收。

GC通过==标记清除，标记复制，标记整理==等算法来回收内存，将对象占用的空间释放出来。


## 5.堆内存的分配
在堆中为对象分配内存主要是两种策略：指针碰撞和空闲列表

### 指针碰撞
主要发生在新生代，大段可用空间
假设堆内存是一个连续的空间，分为两个部分，一个是已经使用的内存，一个是没有使用的内存，==JVM会维护一个指针，指向下一个可用的内存地址，每次分配内存时，只需要将指针向后移动一段距离，如果没有发生碰撞，就将这段内存分配给对象实例==。

### 空闲列表
主要发生在老年代，碎片化空间
==JVM维护一个列表，记录堆中所有未被使用的内存块，每个内存块记录有大小和地址信息。==

当有新的对象请求内存时，JVM会遍历空列表，寻找足够大的空间来堆放新对象。

分配后，==如果选中的内存块没有被完全利用，剩余的部分会作为一个新的内存块加入到空闲列表中。==

## 6.new对象时，堆内存会发生抢占吗？
会，new对象时指针会香油移动一个单位，如果一个线程在正在给s分配空间，另一个线程也给一个对象分配一个空间，就会导致抢占。

解决方法：
JVM为每个线程留了一小块内存空间，叫做TLAB，在线程创建对象时，这个空间权限是私有的，也叫做线程本地分配缓冲区，用于存放该线程分配的对象。

当线程需要分配对象时直接在TLAB中分配，只有当TLAB用尽或者内存空间太大时回到堆内存里面分配。

==TLAB线程私有只是使用权限层面上，在物理内存上是共享的，我们在创建的过程中别人是不能访问这块内存的，但是在创建之后所有的线程都可以引用该线程在TLAB上创建的对象。==

为什么使用TLAB，创建对象实例更快，并且不用在堆上面加锁，有更好的效率。

