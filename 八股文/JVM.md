## 1.什么是JVM
JVM就是我们常说的JAVA虚拟机，他是Java能够跨平台的基石。
程序运行之前，需要先通过编译器将Java源代码文件编译成字节码文件；
程序运行的时候，JVM会逐行对字节码进行解释，翻译成机器码指令，并交给对应的操作系统去执行。不同的版本有不同的JVM，针对操作系统。

实现一次编译处处运行的特点。

其他特性
- JVM可以自动管理内存，就是我们常说的GC回收。通过垃圾回收器将不再使用的对象回收。
- JVM包含一个即时编译器JIT，可以把热点代码翻译成机器码放到CodeCache里面，下次执行的时候不再一行一行的解释，而是直接执行缓存后的机器码，执行效率大幅度提高。
- 任何可以通过Java编译的语言，都可以在JVM运行，例如Kotlin，Groovy等

学习JVM的好处：
- 优化程序性能，避免内存问题
- 了解JVM的内存模型和垃圾回收机制，更便于我们合理分配内存，减少GC停顿
- JVM的类加载机制可以帮我们排查类加载冲突或异常
- JVM提供了很多调试工具，可以帮我们分析内存和线程的使用情况，从而解决内存溢出等问题

JVM的出现原因
跨平台可以用直译器，但是速度过慢，所以推出了JVM虚拟机，可以把字节码文件转换成机器码，转换的时候通过JIT做优化，这样的程序跑起来就快多了。

## 2.JVM的组织架构
类加载器：负责从文件系统，网络或其他来源加载Class文件，将Class文件中的二进制数据读入到内存中。
运行时数据区：JVM在执行JAVA程序时，需要在内存中分配空间来处理各种数据，这些内存区域按照Java虚拟机规范可以划分为方法区，堆，栈，虚拟机栈，程序计数器和本地方法栈。
执行引擎：JVM的心脏，负责执行字节码，包含一个**虚拟处理器**，即时编译器JIT以及垃圾回收器。

## JVM如何运行Java文件

### 编译时
当我们写了一个Java文件的时候，要让JVM运行，首先要通过JAVAC去编译，JAVAC是JDK里面的一个程序，专门用来把.java源文件编译成.class文件也就是字节码文件，在IDEA编译器里，可以使用show bytecode查看字节码文件。

我们在out文件夹里面能直接看到java格式的文件是因为IDEA用了FernFlower反编译工具将字节码文件反编译为我们看的懂的JAVA文件。

字节码包含了JVM的指令，类的元数据信息比如类名，方法和属性等

### 运行时
当我们有了字节码文件，我们就可以启动JVM来运行字节码文件，也就是到了RUN阶段，之前是build阶段。

JVM通过类加载器加载字节码文件，转换成二进制数据存储到运行时数据区，再通过执行引擎转换为机器码，最终交给操作系统执行。

接着执行引擎开始执行代码，我们的字节码指令通常包含多个指令组成，每条指令由一个操作码和若干操作数组成。
#### PC寄存器
JVM靠这些指令来执行程序，在==执行时我们的每个线程一个PC寄存器，它存储当前要执行的字节码指令，执行完一条后执行自动指向下一条，遇到条件分支，PC改成跳转后的地址，遇到native方法PC 置为 `undefined`（因为执行权交给了本地方法）==

#### 线程和栈帧
==每个线程有自己的虚拟机栈，每次调用方法就会往里面放入该方法的栈帧，栈帧里有局部变量，操作数栈，方法返回地址，方法执行完毕栈帧弹出==

#### 线程切换的时候，PC寄存器和虚拟机栈
切换线程时，PC寄存器存放的是当前线程的字节码指令地址（程序计数）
线程私有每个线程有自己的PC
当线程被调度时，JVM会保存当前线程PC寄存器的值（线程的执行位置）
当线程恢复执行时，会恢复之前保存的PC寄存器值，继续从上次停下的指令处执行。

虚拟机栈也是线程私有，保存该线程所有正在执行方法的栈帧
当线程切换时
- 虚拟机栈和栈帧会全部保存，因为他们在自己的线程空间中
- JVM会暂停该线程，但是栈帧信息保持不变。
恢复线程时，JVM会恢复虚拟机栈的状态，栈帧顶帧，局部变量和操作数帧都和上次一样，程序继续执行。

==可以理解为比赛暂停，全部信息不动，等到比赛恢复，全部按照当前暂停前的样子继续执行==
我们可以使用JAVAP查看字节码的指令序列
```
0 getstatic #2 <java/lang/System.out> 3 ldc #3 <Hello World> 5 invokevirtual #4 <java/io/PrintStream.println> 8 return
```
这是一个输出helloword的指令序列
字节码指令通常包含多条指令组成，每条指令由一个操作码和若干操作数组成。
JVM就是靠这些字节码指令来完成程序执行的，常见的执行方式有两种一种是解释执行，对字节码逐条执行，一种是JIT，也就是即时编译，他会在执行热点代码时把热点代码优化并缓存起来，下次再执行时直接使用缓存的机器码执行，不需要再次解释执行，大大增加了执行效率。

## 深入理解JVM运行时数据区

Java文件通过编译器形成.class文件，通过类加载器加载完毕交给执行引擎。在执行的过程中，JVM会划出一块空间来存储程序执行期间用到的数据，这块空间一般被称为运行时数据区

由五部分构成
虚拟机栈，方法区，PC寄存器，堆，本地方法栈

### 程序计数器（PC寄存器）
程序计数器占的内存很小，可以看作是当前线程所执行的字节码指令的行号指示器。字节码解释器会在工作的时候改变这个程序计数器的值来选取下一条需要执行的字节码指令，像循环，分支跳转等都需要这个程序计数器来完成。
在JVM中，线程是可以切换的，因此在任一具体时刻，一个CPU的内核只会执行一个线程中的指令，因此，为了切换线程后能恢复到正确的执行位置，每个线程有个独立的计数器，不能互相干扰，否则会影响正常的执行顺序。

也就是说程序计数器是线程私有的。

如果执行的是本地方法，计数器里面是underdefined，非本地，则保存的是当前需要执行的指令地址。

