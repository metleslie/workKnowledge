## 1.什么是JVM
JVM就是我们常说的JAVA虚拟机，他是Java能够跨平台的基石。
程序运行之前，需要先通过编译器将Java源代码文件编译成字节码文件；
程序运行的时候，JVM会逐行对字节码进行解释，翻译成机器码指令，并交给对应的操作系统去执行。不同的版本有不同的JVM，针对操作系统。

实现一次编译处处运行的特点。

其他特性
- JVM可以自动管理内存，就是我们常说的GC回收。通过垃圾回收器将不再使用的对象回收。
- JVM包含一个即时编译器JIT，可以把热点代码翻译成机器码放到CodeCache里面，下次执行的时候不再一行一行的解释，而是直接执行缓存后的机器码，执行效率大幅度提高。
- 任何可以通过Java编译的语言，都可以在JVM运行，例如Kotlin，Groovy等

学习JVM的好处：
- 优化程序性能，避免内存问题
- 了解JVM的内存模型和垃圾回收机制，更便于我们合理分配内存，减少GC停顿
- JVM的类加载机制可以帮我们排查类加载冲突或异常
- JVM提供了很多调试工具，可以帮我们分析内存和线程的使用情况，从而解决内存溢出等问题

JVM的出现原因
跨平台可以用直译器，但是速度过慢，所以推出了JVM虚拟机，可以把字节码文件转换成机器码，转换的时候通过JIT做优化，这样的程序跑起来就快多了。

## 2.JVM的组织架构
类加载器：负责从文件系统，网络或其他来源加载Class文件，将Class文件中的二进制数据读入到内存中。
运行时数据区：JVM在执行JAVA程序时，需要在内存中分配空间来处理各种数据，这些内存区域按照Java虚拟机规范可以划分为方法区，堆，栈，虚拟机栈，程序计数器和本地方法栈。
执行引擎：JVM的心脏，负责执行字节码，包含一个**虚拟处理器**，即时编译器JIT以及垃圾回收器。

### JVM如何运行Java文件

### 编译时
当我们写了一个Java文件的时候，要让JVM运行，首先要通过JAVAC去编译，JAVAC是JDK里面的一个程序，专门用来把.java源文件编译成.class文件也就是字节码文件，在IDEA编译器里，可以使用show bytecode查看字节码文件。

我们在out文件夹里面能直接看到java格式的文件是因为IDEA用了FernFlower反编译工具将字节码文件反编译为我们看的懂的JAVA文件。

字节码包含了JVM的指令，类的元数据信息比如类名，方法和属性等

### 运行时
当我们有了字节码文件，我们就可以启动JVM来运行字节码文件，也就是到了RUN阶段，之前是build阶段。

JVM通过类加载器加载字节码文件，转换成二进制数据存储到运行时数据区，再通过执行引擎转换为机器码，最终交给操作系统执行。

接着执行引擎开始执行代码，我们的字节码指令通常包含多个指令组成，每条指令由一个操作码和若干操作数组成。
#### PC寄存器
JVM靠这些指令来执行程序，在==执行时我们的每个线程一个PC寄存器，它存储当前要执行的字节码指令，执行完一条后执行自动指向下一条，遇到条件分支，PC改成跳转后的地址，遇到native方法PC 置为 `undefined`（因为执行权交给了本地方法）==

#### 线程和栈帧
==每个线程有自己的虚拟机栈，每次调用方法就会往里面放入该方法的栈帧，栈帧里有局部变量，操作数栈，方法返回地址，方法执行完毕栈帧弹出==

#### 线程切换的时候，PC寄存器和虚拟机栈
切换线程时，PC寄存器存放的是当前线程的字节码指令地址（程序计数）
线程私有每个线程有自己的PC
当线程被调度时，JVM会保存当前线程PC寄存器的值（线程的执行位置）
当线程恢复执行时，会恢复之前保存的PC寄存器值，继续从上次停下的指令处执行。

虚拟机栈也是线程私有，保存该线程所有正在执行方法的栈帧
当线程切换时
- 虚拟机栈和栈帧会全部保存，因为他们在自己的线程空间中
- JVM会暂停该线程，但是栈帧信息保持不变。
恢复线程时，JVM会恢复虚拟机栈的状态，栈帧顶帧，局部变量和操作数帧都和上次一样，程序继续执行。

==可以理解为比赛暂停，全部信息不动，等到比赛恢复，全部按照当前暂停前的样子继续执行==
我们可以使用JAVAP查看字节码的指令序列
```
0 getstatic #2 <java/lang/System.out> 3 ldc #3 <Hello World> 5 invokevirtual #4 <java/io/PrintStream.println> 8 return
```
这是一个输出helloword的指令序列
字节码指令通常包含多条指令组成，每条指令由一个操作码和若干操作数组成。
JVM就是靠这些字节码指令来完成程序执行的，常见的执行方式有两种一种是解释执行，对字节码逐条执行，一种是JIT，也就是即时编译，他会在执行热点代码时把热点代码优化并缓存起来，下次再执行时直接使用缓存的机器码执行，不需要再次解释执行，大大增加了执行效率。

## 3.深入理解JVM运行时数据区

Java文件通过编译器形成.class文件，通过类加载器加载完毕交给执行引擎。在执行的过程中，JVM会划出一块空间来存储程序执行期间用到的数据，这块空间一般被称为运行时数据区

由五部分构成
虚拟机栈，方法区，PC寄存器，堆，本地方法栈

### 程序计数器（PC寄存器）
程序计数器占的内存很小，可以看作是当前线程所执行的字节码指令的行号指示器。字节码解释器会在工作的时候改变这个程序计数器的值来选取下一条需要执行的字节码指令，像循环，分支跳转等都需要这个程序计数器来完成。
在JVM中，线程是可以切换的，因此在任一具体时刻，一个CPU的内核只会执行一个线程中的指令，因此，为了切换线程后能恢复到正确的执行位置，每个线程有个独立的计数器，不能互相干扰，否则会影响正常的执行顺序。

也就是说程序计数器是线程私有的。

如果执行的是本地方法，计数器里面是underdefined，非本地，则保存的是当前需要执行的指令地址。

### Java虚拟机栈
Java虚拟机栈里面是一个个栈帧，每个栈帧对应一个方法，也是线程私有的，当我们执行一个方法的时候，会创建该方法对应的栈帧，并将栈帧压入栈中。

栈帧包含五个部分：
局部变量表
操作数帧
指向运行时常量池的引用
方法返回地址
动态链接
![[Pasted image 20250813095159.png]]
特点：
- 线程私有
- 栈溢出，如果栈的深度超过了JVM所允许的深度，则会报StackOverflowError
默认大小
默认 1024 KB 的 JVM 栈可以执行 10885 次 `testStackOverflowError` 方法，而 256 KB 的 JVM 栈只能执行 1990 次 `testStackOverflowError` 方法，四五倍的样子。

### 本地方法栈
本地方法栈与虚拟机栈类似，虚拟机执行JAVA方法服务，本地方法栈执行Native方法

### 堆
堆是所有线程共享的空间，在JVM启动的时候创建，用来存储对象（数组也是一种对象）
以前Java所有的对象都会在堆中分配，但随着JIT的发展和逃逸技术的形成，不是所有对象都分配到堆上了，JDK7默认开启逃逸分析，一个方法里面如果对象引用没有被返回或者未被外面使用，我们直接把这个对象存到虚拟机栈里面。

这个栈就是前面说的线程私有的虚拟机栈，随着方法调用的结束而消失，也就不需要被垃圾回收了。

逃逸分析（Escape Analysis）是一种编译器优化技术，用于判断对象的作用域和生命周期。如果编译器确定一个对象不会逃逸出方法或线程的范围，它可以选择在栈上分配这个对象，而不是在堆上。这样做可以减少垃圾回收的压力，并提高性能。
==逃逸分析不会出逃不一定是在栈上分配也有可能是标量替换，对象直接拆分成若干局部变量==。

堆除了是对象的聚集地，也是垃圾回收的主要处理区域，也叫做GC堆。

堆容易出现的错误是堆溢出OUTOFMEmoryerror
分为两种情况：
- JVM花太多时间回收并且只能回收很少的空间。
- 创建新对象，堆里面的内存不够创建了，也就是JVM内存太小了
- `OutOfMemoryError: GC Overhead Limit Exceeded`：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生该错误。
- `java.lang.OutOfMemoryError: Java heap space`：假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发该错误。和本机的物理内存无关，和我们配置的虚拟机内存大小有关！

### 元空间和方法区
元空间是一个逻辑区域，不同的版本有不同的实现，1.7是方法区被称为永久代，JDK8的时候，永久代被删除，被元空间替代。

JDK7之前，所有的常量池都在方法区里，之后把字符串常量池放到了堆里。到了JDK8运行时常量池放到了元空间里，字符串常量池还在堆里面

废弃永久代的原因：为了兼容JIT，有JIT功能的JVM没有永久代，为了兼容把永久代取消了，直接占用内存的一部分，并且把这块内存叫做元空间。
元空间大小不再受制于JVM启动时设置的大小，直接利用本地内存，也就是操作系统的内存，有效的解决了OOM的问题。

当元空间的数据增长时，JVM 会请求操作系统分配更多的内存。如果内存空间足够，操作系统就会满足 JVM 的请求。但是也会出现内存溢出的情况。

### 运行时常量池
常量池包含类里面的信息，包括类名，方法名一类的东西，但只是记录信息，并没有直接引用，运行时常量池就是直接引用了堆内的信息，类似于一个存地址，一个直接存坐标。

#### 常量池指什么
并不是简单的常量信息
不光有我们定义的3.14,"hello"
还有符号引用-也就是类名方法名字段名类型一类的
还有final常量
包含类运行前的所有信息

#### 运行时常量池指什么
运行时常量池简单来说就是常量池信息放到了运行时常量池这个新空间也就是元空间里面，但是我们的符号引用，例如一个A方法，常量池里面存储的是包名/类名/某个方法，但是运行时会解析这个地址直接找到堆里面这个方法的地方直接就引用地址了例如上述方法变成了一个1adfa2这种地址，好处是执行效率高，不用在运行时解析了，还有就是符合延迟加载和动态绑定，延迟加载是有些类只使用一次，所以编译时不用解析，动态绑定需要运行的时候才能找到具体使用的方法，你运行时就直接引用可能会错误。

### 字符串常量池
为什么放到堆里面
JDK6之前放到永久代里面，Stringintern方法会把字符串放进永久代的常量池
永久代空间小，放太多导致OOM

JDK就把字符串常量池放到堆里面，这样就不会导致OOM溢出，堆有更高效的GC回收，`String.intern()` 允许运行时动态往字符串常量池里加对象


### 总结
- PC 寄存器（PC Register），也叫程序计数器（Program Counter Register），是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器。
- JVM 栈（Java Virtual Machine Stack），与 PC 寄存器一样，JVM 栈也是线程私有的。每一个 JVM 线程都有自己的 JVM 栈（也叫方法栈），这个栈与线程同时创建，它的生命周期与线程相同。
- 本地方法栈（Native Method Stack），JVM 可能会使用到传统的栈来支持 [Native 方法](https://javabetter.cn/oo/native-method.html)的执行，这个栈就是本地方法栈。
- 堆（Heap），在 JVM 中，堆是可供各条线程共享的运行时内存区域，也是供所有类实例和数据对象分配内存的区域。
- 方法区（Method area），JDK 8 开始，使用元空间取代了永久代。**方法区是 JVM 中的一个逻辑区域**，用于存储类的结构信息，包括类的定义、方法的定义、字段的定义以及字节码指令。不同的是，元空间不再是 JVM 内存的一部分，而是通过本地内存（Native Memory）来实现的。
- [运行时常量池](https://javabetter.cn/jvm/neicun-jiegou.html)，运行时常量池是每一个类或接口的常量在运行时的表现形式，它包括了编译器可知的数值字面量，以及运行期解析后才能获得的方法或字段的引用。简而言之，当一个方法或者变量被引用时，JVM 通过运行时常量区来查找方法或者变量在内存里的实际地址。

## 4.对象创建的过程
当我们使用new关键字创建一个对象的时候，==JVM会在常量池中定位到类的符号引用（包括类名方法名属性等信息），查看符号引用是否解析，如果没有解析则加载类和解析，得到类的直接引用，然后JVM会为对象分配内存在堆里，并完成初始化，例如数值成员变量为0，对象是null等。==

接下来设置对象头，里面包含==对象是哪个类的实例，对象的哈希码，对象的GC分代年龄等信息==。
==最后JVM会执行构造方法《init》完成赋值操作==，将成员变量赋值为预期值例如int age = 18。

### 对象销毁过程
当对象不在被任何类引用时，就会变成垃圾。GC会通过==可达性算法==判断对象是否存活，如果对象不可达，则回收。

GC通过==标记清除，标记复制，标记整理==等算法来回收内存，将对象占用的空间释放出来。


## 5.堆内存的分配
在堆中为对象分配内存主要是两种策略：指针碰撞和空闲列表

### 指针碰撞
主要发生在新生代，大段可用空间
假设堆内存是一个连续的空间，分为两个部分，一个是已经使用的内存，一个是没有使用的内存，==JVM会维护一个指针，指向下一个可用的内存地址，每次分配内存时，只需要将指针向后移动一段距离，如果没有发生碰撞，就将这段内存分配给对象实例==。

### 空闲列表
主要发生在老年代，碎片化空间
==JVM维护一个列表，记录堆中所有未被使用的内存块，每个内存块记录有大小和地址信息。==

当有新的对象请求内存时，JVM会遍历空列表，寻找足够大的空间来堆放新对象。

分配后，==如果选中的内存块没有被完全利用，剩余的部分会作为一个新的内存块加入到空闲列表中。==

## 6.new对象时，堆内存会发生抢占吗？
会，new对象时指针会香油移动一个单位，如果一个线程在正在给s分配空间，另一个线程也给一个对象分配一个空间，就会导致抢占。

解决方法：
JVM为每个线程留了一小块内存空间，叫做TLAB，在线程创建对象时，这个空间权限是私有的，也叫做线程本地分配缓冲区，用于存放该线程分配的对象。

当线程需要分配对象时直接在TLAB中分配，只有当TLAB用尽或者内存空间太大时回到堆内存里面分配。

==TLAB线程私有只是使用权限层面上，在物理内存上是共享的，我们在创建的过程中别人是不能访问这块内存的，但是在创建之后所有的线程都可以引用该线程在TLAB上创建的对象。==

为什么使用TLAB，创建对象实例更快，并且不用在堆上面加锁，有更好的效率。

## 7.对象的内存布局
对象的内存布局是由Java虚拟机规范定义的，具体实现根据JVM的不同版本有所不同。
最常见的HOTPOT举例
对象内存分为：对象头，实例数据和对齐填充

### 对象头
包含元信息，MarkWord，类型指针等
MarkWord：存储对象的运行时状态信息，包括锁，hash值，GC标记等，64位操作系统占八个字节，32占4个
类型指针：指向对象所属类的元数据，也就是class对象，用来支持多态，方法调用等功能
如果对象是数组类型，还会有一个额外的数组长度字段，4个字节。

类型指针可以呗压缩到4字节，不压缩是8字节，默认8字节

### 实例数据
实例数据就是对象实际的字段值，也是成员变量值，按照字段在类中生命的顺序存储。
JVM会对这些数据进行对齐或者重排，提高内存访问速度

### 对齐填充
JVM的内存模型要求对象的起始地址是8字节对齐，因此对象的总大小必须是8的倍数。
如果对象头和实例数据的长度不是8的倍数，会通过填充额外的字节去对齐。
比如说对象头+实例数据为14，则会补2位凑成八的倍数

### 8字节对齐意义
因为CPU进行内存访问时，一次寻址的指针大小是8字节，正好是L1的缓存大小，如果不进行字节对齐，则可能出现跨域缓存行访问，导致额外的缓存行加载，Cpu的访问效率变低。

### new Object占几个字节
64位的话，对象头占12个字节，MarkWord占8个，类型指针默认压缩4个，需要对齐填充4个，站16个字节。

## 对象引用占几个字节
对象引用64位默认4个字节，未开启类型压缩占4个字节

## 8.Jvm如何访问对象的
主流方式两种：一种是句柄，一种直接访问
句柄：
有一个中间表存储对象地址，访问的时候去句柄里面查对应的地址，对象移动只需要改变句柄表的对应的对象地址就行。

直接访问：
引用直接存储对象的内存地址，对象的实例数据和内存信息都存储在固定的内存区域。优点是访问速度快，减少查找句柄表操作，缺点是对象移动的时候，引用需要更新为新的地址。

Hotpot虚拟机主要是直接访问


## 9.对象引用有哪些方式

四种，强引用，弱引用，软引用，虚引用
强引用：就是我们new对象的引用，这种只要强引用关联对象，可达性法则能找到这个引用，就不会被回收。

软引用：用于一些非必需对象，通过softrefenrence类实现，软引用对象在内存不足时会被回收。

弱引用：描述一些生命周期非常短的对象，例如ThreadLocal中的Entry，就是通过weakRefenrence类实现的，弱引用在下次垃圾回收时一定会被回收。不论内存充足与否。

虚引用：虚引用主要用来跟踪对象被回收的过程，通过 PhantomReference 类实现。虚引用的对象在任何时候都可能被回收。

## 10.堆的内存分区
Java堆被分为新生代和老年代两个大区
新生代：
Eden空间和两个Survivor空间（From区和To）
新创建的对象被分为Eden区，当Eden区填满时，会触发一次MinorGC，清除不再使用的对象，存活下来的对象会从Eden区移动到Survivor区。

对象在新生代区经过多个GC后，如果仍然存活会被移动到老年区。当老年代内存不足时，会触发Major GC，对整个堆进行垃圾回收。

## 11.新生代区域划分
新生代的垃圾回收算法用了标记-复制算法，因为新生代对象存活较少，每次复制少量的对象效率比较高。
基于这种算法，虚拟机将内存分为一大块Eden区和两小块survivor区，每次分配内存只使用Eden区和一小块survivor区。GC时，Eden和survicor区仍然存活的对象一次性复制到另一块survivor区，然后直接清理到eden区和另一块survivor区，默认Eden区和survivor的大小比例是8:1。


## 12.对象什么时候到老年区
对象通常在年轻代分配，随着时间的进行和垃圾收集的进程，某些满足条件的对象会进入老年代，例如长期存活的对象。

### 长期存活的对象如何判断
JVM会为对象维护一个年龄统计器，记录对象在新生代中经历minorGC的次数，每次GC未被回收的对象，其年龄会加1。
当超过一个特定阈值，默认值是15，就会被认为是老年对象了，需要重点关照。这个年龄阈值可以通过JVM参数 -XX:`MaxTenuringThreshold`来设置。

1. 如果应用中的对象存活时间较短，可以适当调大这个值，让对象在新生代多待一会儿
2. 如果对象存活时间较长，可以适当调小这个值，让对象更快进入老年代，减少在新生代的复制次数

### 大对象如何判断？
大对象指内存比较大的对象，如大数组长字符串等。

其大小由 JVM 参数 `-XX:PretenureSizeThreshold` 控制，但在 JDK 8 中，默认值为 0，也就是说默认情况下，对象仅根据 GC 存活的次数来判断是否进入老年代。

G1 垃圾收集器中，==大对象会直接分配到 HUMONGOUS 区域。当对象大小超过一个 Region 容量的 50% 时，会被认为是大对象。==

Region 的大小可以通过 JVM 参数 `-XX:G1HeapRegionSize` 来设置，默认情况下从 1MB 到 32MB 不等，会根据堆内存大小动态调整。

可以通过 `java -XX:+UseG1GC -XX:+PrintGCDetails -version` 查看 G1 垃圾收集器的相关信息。

G1垃圾收集器和传统GC收集器是两种收集器。

### 动态年龄判定
如果Survivor区中所有对象的总大小超过了一定比例，通常是Survivor的一半，那么年龄较小的对象也会到老年区。

这事因为如果年龄小的对象在Survicor区中占用了比较大的空间，会导致Survivor区中的对象复制次数增多，影响垃圾回收的效率。

Eden和S0S1的关系。
==当Eden进行GC时，Eden区活着的和S0活着的对象，放到S1，下一次再进行GC的时候S0就变成S1了，S1变成S0了。如果Eden和S0剩余的对象大于S1的内存空间，那么就直接进入到老年代了，这个叫动态年龄判定。==

## 13.STW是什么？
STW是JVM进行垃圾回收的时候，对象会移动，为了保证对象的引用在移动过程中不受改变，必须暂停所有的用户线程，我们叫做STOP THE WORD STW

### 如何暂停线程
JVM会使用一个安全点的机制来保证线程能够正确安全暂停，过程包括四步：
- JVM发出暂停信号
- 线程执行到安全点后，挂起自身并等待垃圾回收完成
- 垃圾完成GC回收
- 线程恢复执行

什么是安全点
安全点是JVM的一种机制，用于STW的垃圾回收，让线程到达特定部位，可以被安全的暂停。

## 14.对象一定分配在堆中吗？
不一定，JVM有逃逸分析和标量替换。
### 逃逸分析
JVM会进行逃逸分析，分析该对象是否只在方法内部，如果是的话，则不存到堆里。存在栈上。
它是一种JVM分析技术，用来分析对象的作用域和生命周期，判断是否逃逸出方法或线程。

### 具体指什么
根据对象的逃逸范围，可以分为方法逃逸和线程逃逸。
如果在方法外部发现有它的引用，生命周期超出了方法到的范围，那么一定就必须分配到堆里。

### 逃逸分析的好处
- 减少垃圾收集的压力，给GC腾出空间。
- 线程需要加锁，但加锁会导致效率低，如果逃逸分析可以分析道该对象不会逃出该线程，那么这个对象就不用加锁，较少线程开销。
- 对象的字段在方法中独立使用，可以将对象分解为标量变量，避免对象分配。

## 15.内存溢出和内存泄漏
内存溢出：简称OOM，是指JVM需要分配空间的时候，发现没有空间可用了，导致内存溢出。
原因可能是，堆，元空间，栈直接内存不足导致的。可以通过优化内存配置，减少对象分配来结局。

内存泄漏是指程序在使用完内存后，未能及时释放，导致一直占用了内存空间。随着时间推移，内存泄漏会导致可用空间越来越少，最终导致内存溢出。
内存泄漏通常是指长期存活的对象一直占用短期存活对象的引用，没有释放，从而导致短期存活对象无法被回收导致的。

用一个例子：内存溢出是没茅坑可用了，内存泄漏是有人一直占用不释放。

## 16.手写内存溢出的例子
可以写一个死循环，创建一个大的数组对象，有个容器一直添加大对象，最终就会导致溢出。
可以通过-Xmx128M设置小的堆内存，然后运行程序，几个循环就会导致溢出。
```
public static void main(String[] args) {  
    List<byte[]> object = new ArrayList<>();  
    try {  
        while (true){  
            byte[] objects = new byte[10*1024*1024];  
            object.add(objects);  
        }  
    }catch (OutOfMemoryError error){  
        System.out.println("OOM发生在第"+object.size()+"次");  
    }  
}
```


## 17.内存泄漏可能由哪些原因导致的？
- 静态集合里面添加的对象过多，没有及时清理；静态变量的生命周期与程序相同，如果静态变量持有的对象将不会被回收。
- 单例模式下对象持有的外部引用没有及时收回，单例对象也是与程序生命周期相同，不会被回收。
- 数据库，IO，SOCKET等资源没有回收。
- ThreadLocl引用没有被清理，线程推出后仍然持有对象引用。在线程执行完后，要调用ThreadLocal的remove方法。

## 18.内存泄漏问题
七个步骤
- jps -l查看Java进程ID
- top -p id 查看进程使用CPU和内存情况
- top -HP id 查看所有线程的cpu和内存情况
- 抓取线程栈：`jstack -F 29452 > 29452.txt`，可以多抓几次做个对比。
- 可以使用`jstat -gcutil [pid] 5000 10` 每隔 5 秒输出 GC 信息，输出 10 次，查看 **YGC** 和 **Full GC** 次数 如果Full GC次数过多就说明大概率存在内存泄漏了，有对象长期占用GC空间
- 生成 `dump` 文件，然后借助可视化工具分析哪个对象非常多，基本就能定位到问题根源了。执行命令 `jmap -dump:format=b,file=heap.hprof 10025` 会输出进程 10025 的堆快照信息，保存到文件 heap.hprof 中。
- 使用图形化工具分析，如 JDK 自带的 **VisualVM**，从菜单 > 文件 > 装入 dump 文件。

## 19.内存溢出问题
以前由于导出的文件内存过大，出现过OOM的问题
第一步，使用 jmap 命令手动生成 Heap Dump 文件：
一般来说：
如果生产环境的内存还有很多空余，可以适当增大堆内存大小来解决，例如 `-Xmx4g` 参数。
或者检查代码中是否存在内存泄漏，如未关闭的资源、长生命周期的对象等。
之后，在本地进行压力测试，模拟高负载情况下的内存表现，确保修改有效，且没有引入新的问题。

## 20.什么时候会发生栈溢出
栈溢出一般是因为调用栈的深度超过JVM允许的最大深度。
本质是因为空间不足，导致无法再为新的栈帧分配内存。

当一个方法被调用的时候，JVM会在该线程的虚拟栈上分配一个栈帧，用于存储该方法的信息。如果方法调用嵌套太深，栈帧不断压入栈中，最终导致空间耗尽，报出StackOverflowError。
最常见的栈溢出问题就是递归调用，如果递归没有正确终止，会导致递归无限进行。
还有可能是栈里面定义了非常大的变量，栈帧变得很大， 导致栈空间很容易耗尽。


# 垃圾收集

## 1.讲讲JVM的垃圾回收机制


