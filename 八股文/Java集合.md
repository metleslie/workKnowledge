## 1.常见集合框架
### 1.Collection接口
List：有序集合，代表是ArrayList，LinkedList
Set：无序，不可重复的集合，代表是HashSet和TreeSet
Queue：一个用于保持元素队列的集合。实现类包括 PriorityQueue、ArrayDeque 等

### 2.Map接口
表示键值对的集合，键映射值，键不可重复，常见的有HashMap，TreeMap等

### 常用工具类
- [Collections](https://javabetter.cn/common-tool/collections.html)：提供了一些对集合进行排序、二分查找、同步的静态方法。
- [Arrays](https://javabetter.cn/common-tool/arrays.html)：提供了一些对数组进行排序、打印、和 List 进行转换的静态方法。

### 集合类的优劣
1. ArrayList 可以看作是一个动态数组，可以在需要时动态扩容数组的容量，只不过需要复制元素到新的数组。优点是访问速度快，可以通过索引直接查找到元素。缺点是插入和删除元素可能需要移动或者复制元素。
    
2. LinkedList 是一个双向链表，适合频繁的插入和删除操作。优点是插入和删除元素的时候只需要改变节点的前后指针，缺点是访问元素时需要遍历链表。
    
3. HashMap 是一个基于哈希表的键值对集合。==优点是可以根据键的哈希值快速查找到值，但有可能会发生哈希冲突，并且不保留键值对的插入顺序。
    
4. LinkedHashMap 在 HashMap 的基础上==增加了一个双向链表来保持键值对的插入顺序

### 队列和栈的区别
队列是一种先进先出的数据结构，第一个加入的元素最先被移除
栈是一个后进先出，最后一个进入的元素最先被移除

### Collection继承了哪些接口？
继承了 Iterable 接口，这意味着所有实现 Collection 接口的类都必须实现 `iterator()` 方法，之后就可以使用增强型 for 循环遍历集合中的元素了。

## 2.ArrayList和LinkedList的区别

### ArrayList 
动态数组，有扩容机制，扩容因子为1.5，使用的时候便与查询与读取，在对应列表的尾部便与插入，对于列表的中间进行插入则速度较慢。
适合频繁访问，读取操作远超过写入操作，末尾添加元素。
存储空间是一个连续的空间，在创建时已经制定好了大小，分配内存之后，大小便固定了，可以通过数组下标快速访问。
### LinkedList

双向链表，靠指针连接，便与插入与删除，但查询较为复杂需要全遍历。
适合频繁插入和删除，不需要快速访问，实现队列和栈。
链表元素存储于内存中的任意位置，每个节点通过指针指向下一个节点，占用内存因为指针的原因比ArrayList每个节点稍大一些。

## 3.说一下ArrayList的扩容机制
在进行插入的时候，会执行ArrayList.size+1操作看是否超过数组长度，超过的话则进行1.5倍扩容，扩容之后再把数据copy进去。

## 4.ArrayList怎么序列化的
writeObject被重写了，自定义序列化逻辑，只序列化有效数据，不序列全部数据，因为列表是在空间一开始就被定义的，不一定放满数据，出于效率的考虑不需要全部序列化。


## 5.什么是快速失败fail-test
一种java集合的错误检测机制。

在用迭代器遍历集合时（for循环也是迭代器遍历），如果线程A在遍历，线程B对列表进行修改，则会抛出异常Concurrent Modification Exception。

- `ArrayList` 的 `modCount` 记录了修改次数。
    
- `iterator` 初始化时会保存一个期望的 `modCount` 值。
    
- 每次 `next()` 调用时会检查 `modCount == expectedModCount`。
    
- 一旦外部通过 `list.remove()` 修改了集合，而不是使用 `iterator.remove()`，`modCount` 变了，检测到不一致就立刻抛出 `ConcurrentModificationException`

java.util 包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如 ArrayList 类。

### fial-safe
采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历
原理：由于迭代时是对原集合进行拷贝遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发 Concurrent Modification Exception。

缺点：基于拷贝内容的优点是避免了 Concurrent Modification Exception，但同样地，==迭代器并不能访问到修改后的内容==，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。

场景：java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如 CopyOnWriteArrayList 类。

## 6.有什么实现ArrayList线程安全的方法？
### 1.collections.synchronizedList()
返回一个线程安全的List，但只针对list里面的add，remove等操作加了syn锁，如果是用迭代器的时候多线程修改还是会导致fail-test错误。

### 2.CopyOnWriteArrayList
它是线程安全的list，遵从了写时复制的原则，每当对列表进行修改时都会创建一个副本，新副本会替代原来的老副本，对旧列表的所有操作读取仍在原有的列表上进行。

通俗的讲，CopyOnWrite 就是当我们往一个容器添加元素的时候，不直接往容器中添加，而是先复制出一个新的容器，然后在新的容器里添加元素，添加完之后，再将原容器的引用指向新的容器。多个线程在读的时候，不需要加锁，因为当前容器不会添加任何元素。这样就实现了线程安全。

这种方式是不会报fail-test错误的，相对应的也看不到改变的元素。

### 3.ArrayList和Vector的区别
Vector是老产物，1.0时候的，保留是因为兼容之前代码，Vecotr是全部线程安全的，但某些场景我们不需要用安全来换取速度，单线程环境下效率较低。


## 7.CopyOnWriteArrayList
它是线程安全版本的ArrayList
CopyOnWrite写时复制
采用了读写分离的并发策略，允许并发读，读操作无锁。写操作的时候，会把list复制一份，然后把元素加到复制的那份，再将原容器的引用指向复制的新容器，不影响读操作，读操作读的是未修改的那个容器。


## 8.讲一下HahsMap底层数据结构

HashMap是一个储存键值对的集合，1.8之后的数据结构为数组+链表+红黑树

```
static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); }
```
### hash分布
HashMap底层是16位数组初始大小，在我们存储一个数据的时候，会通过hash甲酸key的hash值，里面用到了高位参与地位代码，让高位变化影响低位，如果不同的key只有高位不同，可能会造成大量的hash冲突，所以要高位参与低位做一种==扰动函数==，提高Hash分布质量，减少冲突。然后与最开始的16位数组做取模运算，把对应的数据放到对应的Hash桶里。

### 扩容机制
HashMap自动触发扩容，当数组的元素个数（只要存入map里面的都算，和桶存入的数量无关）大于数组长度 * 扩容因子（默认0.75），resize使用该方法进行扩容，获取当前的hashmap的旧数组容量，有最大值和最小值，如果扩容后达到了最大值以上，就取最大值，接着，方法创建一个新的数组 newTable，并将旧数组 oldTable 中的元素转移到新数组 newTable 中。转移过程是通过调用 transfer 方法来实现的。该方法遍历旧数组中的每个桶，并将每个桶中的键值对重新计算哈希值后，将其插入到新数组对应的桶中。扩容后大小原来大小的2倍。

转移完成后，==方法将 HashMap 内部的数组引用 table 指向新数组 newTable==，并重新计算阈值 threshold。新的阈值是新容量 newCapacity 乘以负载因子 loadFactor 的结果。

加载因子默认为0.75是因为在“**哈希冲突**”与“**空间利用率**”两者之间有所取舍，尽量保持平衡，所以使用了统计学原理柏松分布，在两个取舍之间取了平衡。

使用红黑树的条件，==链表长度>8且数组长度>=64,使用红黑树，红黑树节点小于6的时候使用链表。

### 线程不安全
三方面原因：

- 多线程下扩容会死循环（1.8已经修复）
- 多线程下 put 会导致元素丢失（并发时有可能会导致前一个key的值会被后一个覆盖掉）
- put 和 get 并发时会导致 get 到 null（在put后发生了扩容，改变了hash桶的位置，导致get后取了null）

HashMap 是线程不安全的主要是因为它在进行插入、删除和扩容等操作时可能会导致链表的结构发生变化，从而破坏了 HashMap 的不变性。

为了解决这个问题，Java 提供了线程安全的 HashMap 实现类 [ConcurrentHashMap](https://javabebetter.cn/thread/ConcurrentHashMap.html)。ConcurrentHashMap 内部采用了==分段锁（Segment）==，将整个 Map 拆分为多个小的 HashMap，每个==小的 HashMap 都有自己的锁，不同的线程可以同时访问不同的小 Map，从而实现了线程安全==。在进行插入、删除和扩容等操作时，只需要锁住当前小 Map，不会对整个 Map 进行锁定，提高了并发访问的效率。

- HashMap 采用数组+链表/红黑树的存储结构，能够在 O(1)的时间复杂度内实现元素的添加、删除、查找等操作。
- HashMap 是线程不安全的，因此在多线程环境下需要使用[ConcurrentHashMap](https://javabebetter.cn/thread/ConcurrentHashMap.html)来保证线程安全。
- HashMap 的扩容机制是通过扩大数组容量和重新计算 hash 值来实现的，扩容时需要重新计算所有元素的 hash 值，因此在元素较多时扩容会影响性能。
- 在 Java 8 中，HashMap 的实现引入了拉链法、树化等机制来优化大量元素存储的情况，进一步提升了性能。
- HashMap 中的 key 是唯一的，如果要存储重复的 key，则后面的值会覆盖前面的值。
- HashMap 的初始容量和加载因子都可以设置，初始容量表示数组的初始大小，加载因子表示数组的填充因子。一般情况下，初始容量为 16，加载因子为 0.75。
- HashMap 在遍历时是无序的，因此如果需要有序遍历，可以使用[TreeMap](https://javabebetter.cn/collection/treemap.html)。

## 9.红黑树
红黑树是一种自平衡的二叉叉招数
特点
- 每个节点是黑色或红色
- 根节点永远是黑色
- 所有叶子结点都是黑色的
- 红色结点的子节点一定是黑色的
- 从任意节点到其每个叶子结点的红色节点数量是一致的

### 为什么不用二叉树作为hashmap的结构那？
二叉树是最基本的数据结构，每个节点最多两个子节点，但容易出现极端情况，插入的如果是有序的，就容易变成链表结构，查询效率退化成O(n)

### 为什么不用平衡二叉树
平衡二叉树比红黑树要求高，每个节点的左右子节点最多差一个单位，这种高度的平衡保证了极佳的查询效率，相对应的在进行插入和删除时需要频繁的进行旋转来维持结构，维护成本过高。

### 为什么用红黑树
链表的查询效率是O(n),链表长度过长时，查找性能下降，红黑树是一种折中方案，查找插入删除时间复杂度都是O(logn)。

### 红黑树怎么保持平衡
==通过左旋和右旋调整树机构，避免某一侧过深，染色，修复红黑规则，从而保证树的高度不会失衡。==

### 记忆技巧

- 插入时红黑冲突是“**局部**”，一般旋转 + 变色就能修好。
    
- 删除时黑色减少是“**向上传染**”，需要考虑兄弟节点的情况。


## 10.Hashmap的put流程

流程：
第一步：根据hash方法进一步扰动hash值，以减少hash冲突。

第二部：进行第一次的hash扩容，并使用hash值与数组长度进行取模运算，确定索引位置。

第三步：如果当前位置为空，则直接插入，如果key值相同，则进行覆盖，如果不同则发生了hash冲突，链表的话直接进行尾插法，添加节点，如果链表长度大于8则自动转换为树，插入树里。

ps：每次插入新元素，判断是否需要扩容，如果当前元素个数大于阈值则进行二倍的数组长度扩容，并重新进行hash计算进行数据分布。

### 为什么重写equals需要重写hash方法
不重写的话可能会造成，两个一样的值，hashcode不相等，这样的话导致放到两个不同的位置，get的时候无法获取的正确的值，并且比较的时候，相同的值也会变为false，因为hashcode不相等就不会再比较值。

## 11.HashMap怎么查找元素

通过hash值定位hash桶，检查桶第一个节点，不相等的话依次向后查询。

## 12.Hash函数怎么设计的

先拿到hash值，是一个32位的int类型数据，然后再让高16位和低16位进行异或运算，确保高低位都参与到hash计算，做扰动函数，提高hash分布质量，减少冲突。


## 13.为什么hash函数能减少hash冲突
hash表的索引是通过hash桶的数量来取模的，如果刚开始数组长度较短，进行取模运算只能获得低位的数据进行取模运算，很容易导致hash冲突。
==通过异或操作将h的高位引入低位，也就是扰动函数，可以增加hash的随机性，减少冲突。==


## 14.为什么hashmap的容量是2的次方
是为了快速定位元素在底层数组中的下标。

HashMap 是通过 ==`hash & (n-1)` ==来定位元素下标的，n 为数组的大小，也就是 HashMap 底层数组的容量。

数组长度-1 正好相当于一个“低位掩码”——掩码的低位最好全是 1，这样 & 运算才有意义，否则结果一定是 0。

2 幂次方刚好是偶数，偶数-1 是奇数，奇数的二进制最后一位是 1，也就保证了 `hash &(length-1)` 的最后一位可能为 0，也可能为 1（取决于 hash 的值），这样可以保证哈希值的均匀分布。

## 15.如果初始化一个HashMap传入17的数量，会怎样？

会自动扩容到大于17的最小的2的幂次方也就是32，这是因为哈希表的大小最好是2的n次幂，这样进行取模运算的时候，能够高效计算出索引值。

## 16.解决Hash冲突有什么办法那？

### 1.再哈希法
使用两套hash算法，当发生hash冲突的时候使用另一种算法，直到找到空槽，这种办法对算法的要求较高。

### 2.开放地址法
遇到哈希冲突的时候，就去寻找下一个空的槽。有 3 种方法：

- 线性探测：从冲突的位置开始，依次往后找，直到找到空槽。
- 二次探测：从冲突的位置 x 开始，第一次增加 12 个位置，第二次增加 22，直到找到空槽。
- 双重哈希：和再哈希法类似，准备多个哈希函数，发生冲突的时候，使用另外一个哈希函数。

### 3.拉链法
当发生hash冲突的时候，使用链表把hash冲突的元素串起来，Hashmap采用的就是该方法。
判断key相等，hash相等之后再判断值。

## 17.HashMap链表转化为红黑树的阈值为什么是8？

树化发生在 table 数组的长度大于 64，且链表的长度大于 8 的时候。

为什么是 8 呢？源码的注释也给出了答案。

红黑树节点的大小大概是普通节点大小的两倍，所以转红黑树，牺牲了空间换时间，更多的是一种==兜底的策略，保证极端情况下的查找效率==。

阈值为什么要选 8 呢？和统计学有关。理想情况下，使用随机哈希码，链表里的节点符合泊松分布，出现节点个数的概率是递减的，节点个数为 8 的情况，发生概率仅为`0.00000006`。

至于红黑树转回链表的阈值为什么是 6，而不是 8？==是因为如果这个阈值也设置成 8，假如发生碰撞，节点增减刚好在 8 附近，会发生链表和红黑树的不断转换，导致资源浪费。==

## 18.HashMap扩容发生在什么时候？
当hashmap的size大于扩容阈值的时候，也就是容量* 扩容因子。
扩容因子为0.75默认，它是最符合哈希冲突和空间利用率的平衡点，通过柏松分布统计学原理得出。

开始容量是2的四次方，无论 HashMap 是否扩容，其底层的数组长度都应该是 2 的幂次方，因为这样可以通过位运算快速计算出元素的索引。

## 19.HashMap的扩容机制
扩容时会新建一个远容量二倍的新数组。遍历原数组里面元素，将其重新分配。

如果当前桶里面只有一个元素，直接通过hash值与新数组的大小取模重新获取位置。
如果当前是红黑树调用spirit进行分裂树节点，保证平衡。
如果是链表，通过旧hash值与旧的数组大小进行取模运算== 0来作为判断条件，如果条件为真则保留在原索引位置，否则元素移动到原索引+旧数组大小的位置。

jdk7采用头插法重新插入链表节点，这样会导致链表无法保持原有顺序，Jdk8采用尾插法解决了此问题。

### 扩容的时候每个节点都要进行重新计算吗？
不需要，如果hash值与原数组长度进行取模为0的话则不需要进行移动，这样避免了hash运算，提升扩容性能。而且都是进行位运算，速度非常快。

## 20.JDK8对HashMap进行了哪些优化

1.由原来的数组+链表变成了数组+链表+红黑树，有更强的兼容性。如果多个键都到了一个链表上，时间复杂度读取的时候是O(n)红黑树则是O（logn）
2.链表的插入方式由头插法改为尾插法，避免了多线程操作出现循环链表的情况
3.扩容的时机由插入前判断改为插入后判断，这样可以避免每次插入时进行不必要的扩容检查，因为有可能插入后并不需要扩容。
4.hash扰动算法进行了更改，原来的多次移位和或与运算来实现的。jdk8让高16位与低16位进行与或运算，极大程度减少了hash冲突。

## 21.HashMap是线程安全的吗？
不是

1，多线程扩容有可能导致死循环，jdk7的时候头插法处理链表，多线程环境下容易造成死循环，8以后修复了问题改为尾插法。

2.多线程在put元素时有可能导致元素丢失，因为计算出来的位置可能会被另一个线程覆盖掉。

3.putget线程同时操作，可能会在扩容时导致get为空。



## 22.怎么解决线程安全的问题？

可以通过 `Collections.synchronizedMap` 方法返回一个线程安全的 Map，内部是通过 synchronized 对象锁来保证线程安全的，比在方法上直接加 synchronized 关键字更轻量级。

更优雅的解决方案是使用并发工具包下的 [ConcurrentHashMap](https://javabetter.cn/thread/ConcurrentHashMap.html)，使用了[CAS](https://javabetter.cn/thread/cas.html)+ [synchronized 关键字](https://javabetter.cn/thread/synchronized-1.html)来保证线程安全。

![[Pasted image 20250725160242.png]]

## 23.hash内部节点时有序的吗？
无序的，通过hash值随机插入的

## 24.讲讲LinkedHashMap怎么做到有序的

它是在HashMap的基础上维护了一个链表解决的，通过before和after来连接不同的keyvalue以此来获得顺序。

## 25.TreeMap怎么实现有序的

通过红黑树来做到的，红黑树是个是一种自平衡的二叉查找树，在进行插入的时候，会找到最合适的位置，每个节点的左子叶小于自己，右子叶大于自己，插入和删除的时候会通过旋转和染色保证树的平衡。查找的时候从根节点开始，通过二叉查找的特点，逐步递归查找。


## 26.TreeMap和HashMap的区别
一个是数组+链表+红黑树，一个是红黑树
Hashmap没有冲突的时候时间复杂度时O（1）,TreeMap是O(logn)
在执行大量范围查找或有序的遍历的时候适合用TreeMap。

## 27.讲讲HashSet
HashSet底层继承的hashMap，只不过值有一个固定的object填充，键用于操作。

Hashset不常用，制作为列表去重来使用，通过使用hash算法来覆盖数据。

### 与arraylist的区别
一个是基于数组，一个基于hashmap
一个允许重复和为空，一个不允许
一个保证插入顺序，另一个不保证

hashset判定数据重复的原因还是和hashmap一样的，通过hash计算，重复的值则覆盖
